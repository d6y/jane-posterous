title: And yet more about transactions
date: 2008/04/30 10:09:00 -0700
tags: [{"name":"SQLServer","id":3772731}]
author: Jane Dallaway
alias: /and-yet-more-about-transactions

<p><a href="http://jane.dallaway.com/more-on-transactions">Further</a> <a href="http://jane.dallaway.com/tsql-transactions-simple-nesting">transaction</a> work revolved around the investigation of naming transactions, and naming savepoints and understanding the differences.  Again I worked with the theory of nested transactions to try and understand what was going on.<p />So, <strong>stage one</strong> - Labelling the two transactions and committing explicit transactions works fine and as expected<p /><span class="code">&nbsp;&nbsp;DELETE FROM Count -- outside of transaction - a known starting point<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN -- in case there are any transactions still hanging around<p />&nbsp;&nbsp;BEGIN TRAN OuterTransaction<p /> &nbsp;&nbsp;INSERT INTO COUNT VALUES (108)<p />&nbsp;&nbsp;&nbsp;&nbsp;BEGIN TRAN  InnerTransaction<p />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE COUNT SET Count = -108 WHERE Count = 108<p /> &nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN InnerTransaction -- can commit transaction InnerTransaction - result will be -108<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN OuterTransaction<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'Transactions left hanging.'<p />&nbsp;&nbsp;SELECT * FROM COUNT</span><p />This results in one row, with the value -108 and no transactions left hanging.<p />However, if we don't explicitly commit the InnerTransaction, when we commit the OuterTransaction the InnerTransaction is left hanging, so the last <span class="code">SELECT @@TRANCOUNT</span> returns 1 and not 0<p /><span class="code">&nbsp;&nbsp;DELETE FROM Count -- outside of transaction - a known starting point<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN -- in case there are any transactions still hanging around<p />&nbsp;&nbsp;BEGIN TRAN OuterTransaction<p /> &nbsp;&nbsp;INSERT INTO COUNT VALUES (108)<p />&nbsp;&nbsp;&nbsp;&nbsp;BEGIN TRAN  InnerTransaction<p />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE COUNT SET Count = -108 WHERE Count = 108<p /> &nbsp;&nbsp;&nbsp;&nbsp;-- No inner commit / rollback<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN OuterTransaction<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'Transactions left hanging.'<p />&nbsp;&nbsp;SELECT * FROM COUNT</span><p />this results in one row, with the value of -108, but with a transaction left hanging - as we only issued an explicit COMMIT TRAN against the OuterTransaction<p />so we would probably be better to have the OuterTransaction statement which is currently<br /><span class="code">&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN OuterTransaction</span><br />as<br /><span class="code">&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN</span><br />i.e. with no explicit reference to the transaction<p /><strong>Stage Two</strong>, attempting to rollback to a named transaction<p /><span class="code">&nbsp;&nbsp;DELETE FROM Count -- outside of transaction - a known starting point<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN -- in case there are any transactions still hanging around<p />&nbsp;&nbsp;BEGIN TRAN OuterTransaction <p /> &nbsp;&nbsp;INSERT INTO COUNT VALUES (108)<p />&nbsp;&nbsp;&nbsp;&nbsp;BEGIN TRAN  InnerTransaction <p />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE COUNT SET Count = -108 WHERE Count = 108<p /> &nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN InnerTransaction<p /> &nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN OuterTransaction<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'Transactions left hanging.'<p />&nbsp;&nbsp;SELECT * FROM COUNT</span><p />which results in the following error:<br /><span class="code">Msg 6401, Level 16, State 1, Line 77<br />Cannot roll back InnerTransaction. No transaction or savepoint of that name was found.</span><p />as well a single row, with the value of -108, and a transaction left open.<p />This behaviour confused me for quite a while until, after a bit of research and reading, I found the following definition for <a href="http://msdn2.microsoft.com/en-us/library/aa238433(SQL.80).aspx">ROLLBACK TRAN [transaction_name]</a> <p /><em>transaction_name - Is the name assigned to the transaction on BEGIN TRANSACTION. transaction_name must conform to the rules for identifiers, but only the first 32 characters of the transaction name are used. When nesting transactions, transaction_name must be the name from the outermost BEGIN TRANSACTION statement.</em><p />So, instead, we can either rollback to the OuterTransaction explicitly<p /><span class="code">&nbsp;&nbsp;DELETE FROM Count -- outside of transaction - a known starting point<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN -- in case there are any transactions still hanging around<p />&nbsp;&nbsp;BEGIN TRAN OuterTransaction <p /> &nbsp;&nbsp;INSERT INTO COUNT VALUES (108)<p />&nbsp;&nbsp;&nbsp;&nbsp;BEGIN TRAN  InnerTransaction <p />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE COUNT SET Count = -108 WHERE Count = 108<p /> &nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN OuterTransaction<p /> &nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN OuterTransaction<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'Transactions left hanging.'<p />&nbsp;&nbsp;SELECT * FROM COUNT </span><p />which now results in no rows - because everything is rolled back in the inner statement - and no hanging transactions<p />or, in this case, the same effect can be gained from issuing a simple ROLLBACK TRAN :<p /><span class="code">&nbsp;&nbsp;DELETE FROM Count -- outside of transaction - a known starting point<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN -- in case there are any transactions still hanging around<p />&nbsp;&nbsp;BEGIN TRAN OuterTransaction <p /> &nbsp;&nbsp;INSERT INTO COUNT VALUES (108)<p />&nbsp;&nbsp;&nbsp;&nbsp;BEGIN TRAN  InnerTransaction <p />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE COUNT SET Count = -108 WHERE Count = 108<p /> &nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN <p /> &nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN OuterTransaction<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'Transactions left hanging.'<p />&nbsp;&nbsp;SELECT * FROM COUNT</span><p />which again results in no rows, and no hanging transactions<p /><strong>Step three</strong>, use a save point to restrict the amount of data to be rolled back instead of an inner transaction<br /><span class="code">&nbsp;&nbsp;DELETE FROM Count -- outside of transaction - a known starting point<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN -- in case there are any transactions still hanging around<p />&nbsp;&nbsp;BEGIN TRAN OuterTransaction <p /> &nbsp;&nbsp;INSERT INTO COUNT VALUES (108)<p />&nbsp;&nbsp;&nbsp;&nbsp;SAVE TRAN SavePoint<p />&nbsp;&nbsp;&nbsp;&nbsp;UPDATE COUNT SET Count = -108 WHERE Count = 108<p /> &nbsp;&nbsp;&nbsp;&nbsp;ROLLBACK TRAN SavePoint<p /> &nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;COMMIT TRAN<p />&nbsp;&nbsp;IF @@TRANCOUNT &gt; 0<br />&nbsp;&nbsp;&nbsp;&nbsp;SELECT 'Transactions left hanging.'<p />&nbsp;&nbsp;SELECT * FROM COUNT</span><p />This results in one row, with a value of 108, showing that the UPDATE statement has been rolled back leaving just the results of the INSERT statement</p>
