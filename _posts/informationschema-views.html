title: INFORMATION_SCHEMA views
date: 2008/07/08 07:20:00 -0700
tags: [{"name":"code","id":58678549},{"name":"SQLServer","id":58646438}]
author: Jane Dallaway
alias: /informationschema-views

<p>As I <a href="http://jane.dallaway.com/find-a-string-in-a-stored-procedure-revisited">alluded</a> to the other day, I'm gradually weaning myself off my dependency on (the fairly ugly) <a href="http://msdn.microsoft.com/en-us/library/ms190324.aspx">sys.objects</a>, <a href="http://msdn.microsoft.com/en-us/library/ms176106.aspx">sys.columns</a> etc as a way to query the meta data about my database.  Instead I'm using the SQL-92 compliant <a href="http://msdn.microsoft.com/en-us/library/ms186778.aspx">INFORMATION_SCHEMA views</a>.<p /></p>
<blockquote class="posterous_medium_quote">Information schema views provide an internal, system table-independent view of the SQL Server metadata. Information schema views enable applications to work correctly although significant changes have been made to the underlying system tables. The information schema views included in SQL Server 2005 comply with the SQL-92 standard definition for the INFORMATION_SCHEMA.</blockquote>
<p><p />So now, when I'm writing database upgrade scripts and attempting to write <a href="http://jane.dallaway.com/defensive-sql-updates">defensive SQL</a> (which is my usual position these days, regardless of whether I think the script will be run more than once - lets just say I've learnt from making such assumptions) I usually wrap <br /><span class="code">ALTER TABLE</span> <br />statements within <br /><span class="code">IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE Table_Name = 'MyTable' AND Column_Name = 'MyNewColumn')</span>, <br /><span class="code"> CREATE TABLE</span> <br />statements within <br /><span class="code">IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE Table_Name = 'MyTable')</span> etc<p />The main area that I have to revert to the sys views for is indexes, and finding out what columns are included in which index, which is the uglier, but no-less-effective<br /><span class="code">SELECT<br />&nbsp;&nbsp;OBJECT_NAME (i.object_id) AS Tablename,<br />&nbsp;&nbsp;i.name AS IndexName,<br />&nbsp;&nbsp;c.name AS ColumnName,<br />&nbsp;&nbsp;CASE ic.is_descending_key<br />&nbsp;&nbsp;WHEN 1 THEN 'DESC'<br />&nbsp;&nbsp;ELSE 'ASC'<br />&nbsp;&nbsp;END as ColumnSort<br />FROM sys.indexes i<br />INNER JOIN sys.index_columns ic <br />ON i.object_id = ic.object_id<br />AND i.index_id = ic.index_id<br />INNER JOIN sys.columns c <br />ON ic.object_id = c.object_id<br />AND ic.column_id = c.column_id<br />INNER JOIN sys.objects o<br />on c.object_id = o.object_id<br />WHERE o.type = 'U'<br />ORDER BY TableName, indexName, ic.key_ordinal</span><p />MSDN has an interesting article <a href="http://msdn.microsoft.com/en-us/library/ms345522.aspx">Querying the SQL Server System Catalog FAQ</a> which has examples for finding out (using the various <a href="http://msdn.microsoft.com/en-us/library/ms189783.aspx">object catalog views</a>) many different areas of meta data across a SQL Server 2005 database and is worth using as a starting point.</p>
